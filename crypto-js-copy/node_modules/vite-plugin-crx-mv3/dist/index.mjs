import {
  CONTENT_SCRIPT_DEV_PATH,
  SERVICE_WORK_DEV_PATH,
  UPDATE_CONTENT,
  VITE_PLUGIN_CRX_MV3,
  __dirname,
  stubId
} from "./chunk-X5N3P3FY.mjs";

// src/index.ts
import { WebSocketServer } from "ws";
import { resolve as resolve4, dirname as dirname3, extname, basename as basename2, join as join3 } from "path";

// src/utils.ts
import os from "os";
import acorn from "acorn";
import { dirname, join, resolve, posix } from "path";
import { access, writeFile, mkdir, readFile } from "fs/promises";
function isJsonString(str) {
  try {
    return !!(JSON.parse(str) && str);
  } catch (e) {
    return false;
  }
}
function slash(p) {
  return p.replace(/\\/g, "/");
}
function normalizePath(id) {
  return posix.normalize(os.platform() === "win32" ? slash(id) : id);
}
function normalizePathResolve(p1, p2) {
  return normalizePath(resolve(p1, p2));
}
var normalizeJsFilename = (p) => p.replace(/\.[tj]sx?/, ".js");
var normalizeCssFilename = (p) => p.replace(/\.(less|scss)/, ".css");
function relaceCssUrlPrefix(code) {
  return code.replace(/(?<=url\()[\s\S]*?(?=\))/gm, function(str) {
    return "chrome-extension://" + slash(join("__MSG_@@extension_id__", str.trim()));
  });
}
function relaceResourcePathPrefix(code) {
  return code.replace(
    /(?<=(=))"[^(?!")]+(\.png|jpg|jpeg|svg|webp|gif|mp3|mp4|avi|rmvb|mpeg|ra|ram|mov|wmv|pdf)"(?=,|;)/gm,
    function(str) {
      return str.startsWith("http") ? str : `chrome.runtime.getURL(${str})`;
    }
  );
}
function isObject(value) {
  return Object.prototype.toString.call(value) === "[object Object]";
}
var isString = (value) => typeof value === "string";
async function emitFile(path2, content) {
  try {
    let dirName = dirname(path2);
    const isDirExist = await access(dirName).then(() => true).catch(() => false);
    if (!isDirExist) {
      await mkdir(dirName, { recursive: true });
      await emitFile(path2, content);
    } else {
      await writeFile(path2, content);
    }
  } catch (error) {
    console.log(error);
  }
}
async function getContentFromCache(cache, path2, readFileOpts = null) {
  let content;
  if (!cache.has(path2)) {
    content = await readFile(path2, readFileOpts);
    cache.set(path2, content);
  } else {
    content = cache.get(path2);
  }
  return content;
}
function removeCommentsFromCode(code) {
  const comments = [];
  acorn.parse(code, {
    ecmaVersion: 2020,
    onComment: comments,
    sourceType: "module"
  });
  for (let i = comments.length - 1; i >= 0; i--) {
    const comment = comments[i];
    code = code.slice(0, comment.start) + code.slice(comment.end);
  }
  return code;
}

// src/processors/manifest.ts
import { watch } from "rollup";
import { basename, resolve as resolve3, dirname as dirname2, join as join2 } from "path";

// src/processors/asset.ts
import { normalize as normalize3 } from "path";

// src/compiler/compile-sass.ts
import { normalize } from "path";
import { createRequire } from "module";
var require2 = createRequire(import.meta.url);
var tildeImporter = (url) => {
  if (url.includes("~")) {
    url = url.replace("~", "");
    if (!url.includes(".scss")) {
      url += ".scss";
    }
    url = require2.resolve(url);
  }
  return { file: url };
};
async function compileSass(context, originalPath, fullPath) {
  const { renderSync } = require2("sass");
  const { css } = renderSync({ file: fullPath, importer: tildeImporter });
  context.emitFile({
    type: "asset",
    source: css,
    fileName: normalize(normalizeCssFilename(originalPath))
  });
}

// src/compiler/compile-less.ts
import { readFileSync } from "fs";
import { normalize as normalize2 } from "path";
import { createRequire as createRequire2 } from "module";
var require3 = createRequire2(import.meta.url);
async function compileLess(context, originalPath, fullPath) {
  const less = require3("less");
  const source = readFileSync(fullPath, "utf8");
  const { css } = await less.render(source, {
    paths: [process.cwd()],
    compress: true
  });
  context.emitFile({
    type: "asset",
    source: css,
    fileName: normalize2(normalizeCssFilename(originalPath))
  });
}

// src/processors/asset.ts
import { readFileSync as readFileSync2 } from "fs";
async function emitAsset(context, originalPath, fullPath) {
  if (originalPath.endsWith(".less")) {
    await compileLess(context, originalPath, fullPath);
  } else if (originalPath.endsWith(".scss")) {
    await compileSass(context, originalPath, fullPath);
  } else {
    let content = readFileSync2(fullPath);
    context.emitFile({
      type: "asset",
      source: content,
      fileName: normalize3(originalPath)
    });
  }
}

// src/processors/serviceWork.ts
var fileContentRex = /(?<=['"`])(.*?)(?=['"`])/g;
var chromeScriptingRex = /chrome\s*\.\s*scripting\s*\.\s*(executeScript|insertCSS|removeCSS|registerContentScripts)\s*\(\s*([\s\S]*?)\s*\)/g;
async function generageDynamicImports(context, manifestContext, code) {
  let files = [];
  let modifiedCode = code.replace(chromeScriptingRex, (match) => {
    let fileMatches = match.match(fileContentRex);
    if (Array.isArray(fileMatches)) {
      files = [...files, ...fileMatches];
    }
    return match.replace(fileContentRex, (filePath) => {
      if (filePath.endsWith(".ts")) {
        return normalizeJsFilename(filePath);
      } else if (/\.(less|scss)$/.test(filePath)) {
        return normalizeCssFilename(filePath);
      } else {
        return filePath;
      }
    });
  });
  let uniqueFiles = [...new Set(files)];
  for (const filePath of uniqueFiles) {
    if (/\.(js|ts)$/.test(filePath)) {
      await manifestContext.doBuild(context, filePath);
    }
    if (/\.(css|less|scss)$/.test(filePath)) {
      let fullPath = normalizePathResolve(manifestContext.srcDir, filePath);
      emitAsset(context, filePath, fullPath);
    }
  }
  return modifiedCode;
}

// src/processors/contentScripts.ts
import { resolve as resolve2 } from "path";
var dynamicImportRex = /(?<=chrome.runtime.getURL\()[\s\S]*?(?=\))/gm;
async function generageDynamicImportScript(context, manifestContext, code) {
  let sources = [];
  let content = code.replace(dynamicImportRex, (filePath) => {
    filePath = filePath.replace(/"|'/g, "").trim();
    sources.push(filePath);
    let normalizePath2 = normalizeJsFilename(normalizeCssFilename(filePath));
    return `"${normalizePath2}"`;
  });
  for (const filePath of sources) {
    if (/\.(js|ts)$/.test(filePath)) {
      await manifestContext.doBuild(context, filePath);
    } else {
      if (!filePath.endsWith(".html")) {
        let fullPath = resolve2(manifestContext.srcDir, filePath);
        await emitAsset(context, filePath, fullPath);
      }
    }
  }
  return content;
}
async function emitDevScript(context, port, manifestContext, reloadPage) {
  let viteConfig = manifestContext.options.viteConfig;
  let manifest = manifestContext.manifest;
  let serviceWorkerPath = manifestContext.serviceWorkerAbsolutePath;
  let contentScripts = manifest == null ? void 0 : manifest.content_scripts;
  if (viteConfig.mode === "production")
    return manifest;
  if (!serviceWorkerPath && (contentScripts == null ? void 0 : contentScripts.length)) {
    let swPath = normalizePathResolve(__dirname, "client/sw.js");
    let content = await getContentFromCache(context.cache, swPath);
    manifest.background = {
      service_worker: SERVICE_WORK_DEV_PATH
    };
    context.emitFile({
      type: "asset",
      source: content,
      fileName: SERVICE_WORK_DEV_PATH
    });
  }
  if (!contentScripts) {
    manifest.content_scripts = [];
  }
  if (serviceWorkerPath || (contentScripts == null ? void 0 : contentScripts.length)) {
    let code = `var PORT=${port},MENIFEST_NAME='${manifest.name}',RELOADPAGE=${reloadPage};`;
    let contentScriptDevPath = normalizePathResolve(
      __dirname,
      "client/content.js"
    );
    let content = await getContentFromCache(
      context.cache,
      contentScriptDevPath,
      "utf8"
    );
    context.emitFile({
      type: "asset",
      source: code + content,
      fileName: CONTENT_SCRIPT_DEV_PATH
    });
    manifest.content_scripts = [
      ...manifest.content_scripts,
      {
        matches: ["<all_urls>"],
        js: [CONTENT_SCRIPT_DEV_PATH]
      }
    ];
  }
  return manifest;
}

// src/processors/manifest.ts
var ManifestProcessor = class {
  cache = /* @__PURE__ */ new Map();
  plugins = [];
  assetPaths = [];
  contentScriptChunkModules = [];
  webAccessibleResources = [];
  srcDir;
  serviceWorkerAbsolutePath;
  manifest = {};
  options;
  packageJsonPath = "";
  constructor(options) {
    this.options = options;
    this.srcDir = dirname2(options.manifestPath);
    this.plugins = options.viteConfig.plugins.filter(
      (p) => p.name !== VITE_PLUGIN_CRX_MV3
    );
    let manifestAbsolutPath = normalizePathResolve(
      options.viteConfig.root,
      options.manifestPath
    );
    try {
      this.packageJsonPath = normalizePath(join2(process.cwd(), "package.json"));
    } catch (error) {
    }
    if (options.viteConfig.build.watch)
      this.watchPackageJson(this.packageJsonPath);
    this.loadManifest(manifestAbsolutPath);
  }
  watchPackageJson(input) {
    if (!input)
      return;
    const watcher = watch({ input });
    watcher.on("event", (event) => {
      if (event.code == "START") {
        this.cache.delete(input);
      }
    });
  }
  async doBuild(context, filePath) {
    const { rollup } = await import("rollup");
    const fileFullPath = normalizePathResolve(this.srcDir, filePath);
    context.addWatchFile(fileFullPath);
    const bundle = await rollup({
      context: "globalThis",
      input: fileFullPath,
      plugins: this.plugins,
      cache: this.cache.get(fileFullPath)
    });
    if (!this.cache.has(fileFullPath)) {
      this.cache.set(fileFullPath, bundle.cache);
    }
    try {
      const { output } = await bundle.generate({
        entryFileNames: normalizeJsFilename(filePath)
      });
      const outputChunk = output[0];
      context.emitFile({
        type: "asset",
        source: outputChunk.code,
        fileName: outputChunk.fileName
      });
    } finally {
      await bundle.close();
    }
  }
  async loadManifest(manifestPath) {
    var _a;
    let packageJson = {};
    if (this.packageJsonPath) {
      let content = await getContentFromCache(this.cache, this.packageJsonPath);
      packageJson = JSON.parse(content);
    }
    let manifestContent = await getContentFromCache(
      this.cache,
      manifestPath,
      "utf8"
    );
    if (!isJsonString(manifestContent)) {
      throw new Error("The manifest.json is not valid.");
    }
    const manifest = JSON.parse(manifestContent);
    manifest.name = !manifest.name || manifest.name == "auto" ? packageJson.name : manifest.name;
    manifest.version = !manifest.version || manifest.version == "auto" ? packageJson.version : manifest.version;
    if (!manifest.name) {
      throw new Error("The name field of manifest.json is required.");
    }
    if (!manifest.version) {
      throw new Error("The version field of manifest.json is required.");
    }
    if (!manifest.manifest_version) {
      throw new Error(
        "The manifest_version field of manifest.json is required."
      );
    }
    this.manifest = manifest;
    let serviceworkerPath = (_a = this.manifest.background) == null ? void 0 : _a.service_worker;
    this.serviceWorkerAbsolutePath = serviceworkerPath ? normalizePathResolve(this.srcDir, serviceworkerPath) : "";
  }
  async reLoadManifest(manifestPath) {
    await this.loadManifest(manifestPath);
    this.webAccessibleResources = [];
  }
  clearCacheById(context, id) {
    if (context.cache.has(id)) {
      context.cache.delete(id);
    }
    if (this.cache.has(id)) {
      this.cache.delete(id);
    }
  }
  getHtmlPaths() {
    var _a, _b, _c;
    const manifest = this.manifest;
    return [
      (_a = manifest.action) == null ? void 0 : _a.default_popup,
      Object.values(manifest.chrome_url_overrides ?? {}),
      manifest.devtools_page,
      manifest.options_page,
      (_b = manifest.options_ui) == null ? void 0 : _b.page,
      (_c = manifest.sandbox) == null ? void 0 : _c.pages
    ].flat().filter((x) => isString(x)).map((p) => resolve3(this.srcDir, p));
  }
  getContentScriptPaths() {
    let paths = [];
    for (const item of this.manifest.content_scripts ?? []) {
      if (Array.isArray(item.js)) {
        paths = [...paths, ...item.js];
      }
    }
    return paths.map((p) => normalizePathResolve(this.srcDir, p));
  }
  async transform(code, id, context) {
    let data = "";
    if (this.serviceWorkerAbsolutePath === id) {
      let swPath = normalizePathResolve(__dirname, "client/sw.js");
      let content = await getContentFromCache(context.cache, swPath, "utf8");
      data += content;
    }
    if (this.getContentScriptPaths().includes(id) || this.serviceWorkerAbsolutePath === id) {
      code = removeCommentsFromCode(code);
    }
    code = await generageDynamicImportScript(
      context,
      this,
      code
    );
    code = await generageDynamicImports(context, this, code);
    return data + code;
  }
  async generateDevScript(context, port, reloadPage) {
    this.manifest = await emitDevScript(
      context,
      port,
      this,
      reloadPage
    );
  }
  async generateManifest(context, bundle, bundleMap) {
    var _a, _b, _c, _d;
    let manifest = this.manifest;
    for (const item of manifest.content_scripts ?? []) {
      for (const [index, css] of (item.css ?? []).entries()) {
        if (item.css) {
          item.css[index] = normalizeCssFilename(css);
        }
      }
      for (const [index, script] of (item.js ?? []).entries()) {
        let scriptAbsolutePath = normalizePathResolve(this.srcDir, script);
        let chunk = bundleMap[scriptAbsolutePath];
        if (chunk) {
          let importedCss = [...chunk.viteMetadata.importedCss];
          let importedAssets = [...chunk.viteMetadata.importedAssets];
          this.webAccessibleResources = [
            ...this.webAccessibleResources,
            ...importedCss,
            ...importedAssets,
            ...chunk.imports,
            chunk.fileName
          ];
          for (const chunkImport of chunk.imports) {
            if (bundle[chunkImport]) {
              let importedCss2 = bundle[chunkImport].viteMetadata.importedCss;
              item.css = [...item.css ?? [], ...importedCss2];
            }
          }
          if (importedCss.length) {
            item.css = [...item.css ?? [], ...importedCss];
          }
          item.js[index] = "contentscript-loader-" + basename(chunk.fileName);
          let content = `(function () {
            (async () => {
                  await import(
                    chrome.runtime.getURL("${chunk.fileName}")
                  );
                })().catch(console.error);
            })();`;
          let outDir = this.options.viteConfig.build.outDir;
          let outputPath = outDir + "/" + item.js[index];
          await emitFile(outputPath, content);
          console.log(`
${outDir}/\x1B[32m${item.js[index]}\x1B[`);
        }
      }
    }
    if (this.serviceWorkerAbsolutePath) {
      manifest.background = {
        ...manifest.background,
        service_worker: bundleMap[this.serviceWorkerAbsolutePath].fileName
      };
    }
    if ((_a = manifest.action) == null ? void 0 : _a.default_popup) {
      manifest.action.default_popup = basename(manifest.action.default_popup);
    }
    if (manifest.devtools_page) {
      manifest.devtools_page = basename(manifest.devtools_page);
    }
    if (manifest.options_page) {
      manifest.options_page = basename(manifest.options_page);
    }
    if ((_b = manifest.options_ui) == null ? void 0 : _b.page) {
      manifest.options_ui.page = basename(manifest.options_ui.page);
    }
    if ((_c = manifest.sandbox) == null ? void 0 : _c.pages) {
      manifest.sandbox.pages = manifest.sandbox.pages.map(
        (page) => basename(page)
      );
    }
    for (const key of Object.keys(manifest.chrome_url_overrides || {})) {
      if ((_d = manifest.chrome_url_overrides) == null ? void 0 : _d[key]) {
        manifest.chrome_url_overrides[key] = basename(
          manifest.chrome_url_overrides[key]
        );
      }
    }
    if (this.webAccessibleResources.length) {
      manifest.web_accessible_resources = [
        ...manifest.web_accessible_resources ?? [],
        {
          matches: ["<all_urls>"],
          resources: this.webAccessibleResources,
          use_dynamic_url: true
        }
      ];
    }
    context.emitFile({
      type: "asset",
      source: JSON.stringify(manifest, null, 2),
      fileName: "manifest.json"
    });
  }
  getAssetPaths() {
    var _a, _b;
    let assetPaths = [];
    const defaultIcon = (_b = (_a = this.manifest) == null ? void 0 : _a.action) == null ? void 0 : _b.default_icon;
    if (defaultIcon && isString(defaultIcon)) {
      assetPaths = [defaultIcon];
    } else if (isObject(defaultIcon)) {
      let defaultIconPaths = Object.values(defaultIcon);
      assetPaths = [...assetPaths, ...defaultIconPaths];
    }
    if (isObject(this.manifest.icons)) {
      let iconPaths = Object.values(this.manifest.icons);
      assetPaths = [...assetPaths, ...iconPaths];
    }
    if (Array.isArray(this.manifest.content_scripts)) {
      this.manifest.content_scripts.forEach((item) => {
        if (Array.isArray(item.css)) {
          assetPaths = [...assetPaths, ...item.css];
        }
      });
    }
    return assetPaths;
  }
  async generateAsset(context) {
    this.assetPaths = this.getAssetPaths();
    for (const path2 of this.assetPaths) {
      let fullPath = normalizePathResolve(this.srcDir, path2);
      context.addWatchFile(fullPath);
      emitAsset(context, path2, fullPath);
    }
  }
};

// src/processors/i18n.ts
import { readdir, stat } from "fs/promises";
import path from "path";
import fs from "fs";
async function getAllFilePaths(directoryPath) {
  try {
    const files = await readdir(directoryPath);
    const filePaths = [];
    for (const file of files) {
      const filePath = path.join(directoryPath, file);
      const fileStats = await stat(filePath);
      if (fileStats.isFile()) {
        filePaths.push(filePath);
      } else if (fileStats.isDirectory()) {
        const subDirFilePaths = await getAllFilePaths(filePath);
        filePaths.push(...subDirFilePaths);
      }
    }
    return filePaths;
  } catch (err) {
    throw err;
  }
}
async function generateLocales(context, srcPath) {
  let localesDir = path.join(srcPath, "_locales");
  if (fs.existsSync(localesDir)) {
    const fileFullPaths = await getAllFilePaths(localesDir);
    for (const fileFullPath of fileFullPaths) {
      context.addWatchFile(fileFullPath);
      const relativePath = path.relative(srcPath, fileFullPath);
      emitAsset(context, relativePath, normalizePath(fileFullPath));
    }
  }
}

// src/http.ts
import { createServer } from "http";
async function httpServerStart(port) {
  const server = createServer();
  return new Promise((resolve5, reject) => {
    const onError = (e) => {
      if (e.code === "EADDRINUSE") {
        console.log(`Port ${port} is in use, trying another one...`);
        server.listen(++port);
      } else {
        server.removeListener("error", onError);
        reject(e);
      }
    };
    server.on("error", onError);
    server.listen(port, () => {
      console.log("WebSocket server started on port: ", port);
      server.removeListener("error", onError);
      resolve5({ port, server });
    });
  });
}

// src/index.ts
function crxMV3(options = {}) {
  let { port = 8181, manifest = "", reloadPage = true } = options;
  if (!manifest || typeof manifest != "string" || typeof manifest == "string" && !manifest.endsWith("manifest.json")) {
    throw new Error(
      "The manifest parameter is required and the value must be the path to the chrome extension's manifest.json."
    );
  }
  let socket;
  let changedFilePath;
  let manifestAbsolutPath;
  let manifestProcessor;
  let srcDir = dirname3(manifest);
  let config;
  let popupAbsolutePath;
  let popupMoudles = [];
  async function websocketServerStart(manifest2) {
    var _a, _b;
    if (config.mode === "production" || !((_a = manifest2 == null ? void 0 : manifest2.background) == null ? void 0 : _a.service_worker) && !((_b = manifest2 == null ? void 0 : manifest2.content_scripts) == null ? void 0 : _b.length)) {
      return;
    }
    const serverOptions = await httpServerStart(port);
    const server = serverOptions.server;
    port = serverOptions.port;
    const wss = new WebSocketServer({ noServer: true });
    wss.on("connection", function connection(ws) {
      console.log(`\x1B[32m[${VITE_PLUGIN_CRX_MV3}]\x1B[0m client connected.`);
      ws.on("message", () => {
        ws.send("keep websocket alive.");
      });
      ws.on("close", () => {
        console.log(
          `\x1B[32m[${VITE_PLUGIN_CRX_MV3}]\x1B[0m client disconnected.`
        );
      });
      socket = ws;
    });
    server.on("upgrade", function upgrade(request, socket2, head) {
      if (request.url === `/${encodeURI(manifest2.name)}/crx`) {
        wss.handleUpgrade(request, socket2, head, function done(ws) {
          wss.emit("connection", ws, request);
        });
      } else {
        socket2.destroy();
      }
    });
  }
  return {
    name: VITE_PLUGIN_CRX_MV3,
    apply: "build",
    async configResolved(_config) {
      var _a;
      config = _config;
      manifestAbsolutPath = normalizePathResolve(config.root, manifest);
      manifestProcessor = new ManifestProcessor({
        manifestPath: manifest,
        viteConfig: config
      });
      await manifestProcessor.loadManifest(manifestAbsolutPath);
      await websocketServerStart(manifestProcessor.manifest);
      let defaultPopupPath = (_a = manifestProcessor.manifest.action) == null ? void 0 : _a.default_popup;
      if (defaultPopupPath) {
        popupAbsolutePath = normalizePathResolve(srcDir, defaultPopupPath);
      }
    },
    async options({ input, ...options2 }) {
      await manifestProcessor.reLoadManifest(manifestAbsolutPath);
      let htmlPaths = manifestProcessor.getHtmlPaths();
      let contentScriptPaths = manifestProcessor.getContentScriptPaths();
      let buildInput = config.build.rollupOptions.input;
      let finalInput = input;
      let serviceWorkerPath = manifestProcessor.serviceWorkerAbsolutePath ? [manifestProcessor.serviceWorkerAbsolutePath] : [];
      if (Array.isArray(buildInput)) {
        finalInput = [
          ...buildInput,
          ...htmlPaths,
          ...contentScriptPaths,
          ...serviceWorkerPath,
          stubId
        ];
      } else if (isObject(buildInput)) {
        const entryObj = { stub: stubId };
        for (const item of [
          ...htmlPaths,
          ...contentScriptPaths,
          ...serviceWorkerPath
        ]) {
          const name = basename2(item, extname(item));
          entryObj[name] = resolve4(srcDir, item);
        }
        finalInput = { ...buildInput, ...entryObj };
      } else {
        finalInput = [
          buildInput && isString(buildInput) ? buildInput : stubId,
          ...htmlPaths,
          ...contentScriptPaths,
          ...serviceWorkerPath
        ];
      }
      return { input: finalInput, ...options2 };
    },
    watchChange(id) {
      changedFilePath = normalizePath(id);
      manifestProcessor.clearCacheById(this, changedFilePath);
      console.log(`\x1B[35mFile change detected :\x1B[0m ${changedFilePath}`);
    },
    async buildStart() {
      this.addWatchFile(manifestAbsolutPath);
      await manifestProcessor.generateDevScript(this, port, reloadPage);
      await manifestProcessor.generateAsset(this);
      await generateLocales(this, join3(config.root, srcDir));
    },
    transform(code, id) {
      return manifestProcessor.transform(code, id, this);
    },
    resolveId(source) {
      if (source === stubId)
        return stubId;
      return null;
    },
    load(id) {
      if (id === stubId)
        return `console.log('stub')`;
      return null;
    },
    async generateBundle(options2, bundle) {
      let bundleMap = {};
      let contentScriptPaths = manifestProcessor.getContentScriptPaths();
      let contentScriptImportedCss = [];
      for (const [key, chunk] of Object.entries(bundle)) {
        if (chunk.type === "chunk" && chunk.facadeModuleId) {
          if (chunk.facadeModuleId === stubId) {
            delete bundle[key];
          } else if (chunk.facadeModuleId === popupAbsolutePath) {
            popupMoudles = Object.keys(chunk.modules);
          } else {
            bundleMap[chunk.facadeModuleId] = chunk;
            if (contentScriptPaths.includes(chunk.facadeModuleId)) {
              let output = bundle[key];
              output.code = relaceResourcePathPrefix(output.code);
              contentScriptImportedCss = [
                ...contentScriptImportedCss,
                ...output.viteMetadata.importedCss
              ];
            }
          }
        }
      }
      for (const fileName of contentScriptImportedCss) {
        let output = bundle[fileName];
        output.source = isString(output.source) ? relaceCssUrlPrefix(output.source) : "";
      }
      await manifestProcessor.generateManifest(this, bundle, bundleMap);
    },
    writeBundle() {
      if (socket) {
        if (!popupMoudles.includes(changedFilePath)) {
          socket.send(UPDATE_CONTENT);
        }
      }
    }
  };
}
export {
  crxMV3 as default
};
